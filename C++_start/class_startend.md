## 流插入运算符重载<<
void operator<<(ostream& out)
{
    out<<   <<   <<
}
若要是返回连续流插入
ostream& operator<<()
{
    return out;
}
//若想调换位置，与流插入习惯相同，一是调用成员函数读取数据，二是再对象中添加友元声明

`
*friend void operator<<();*
`

//printf/scanf不能很好支持自定义类型，而流插入流提取可以结合运算符重载让对象插入提取

## 流提取，不能加const
istream& operator>>()
{
    in>>xxx>>saasa>>ASasasasl;//多个输入默认换行空格分隔
}


##  Re:构造函数
1、函数体内初始化
函数内部的初始化函数
2、初始化列表//两者可以混着用，但能用初始化列表就用，比如栈的初始化，最好两者混着用
以冒号开始，以逗号分隔，每个成员变量之后放一个括号中的初始值，或者是表达式
`
date(xxxxxxxxxx)
    :_year(year)
    ,_month(month)
{}
`

3、初始化列表是每个成员定义的地方，也就是开空间的地方，甚至可以定义const变量和引用(利用初始化列表)以及自定义类型不调用构造函数时_st1(capacity)

4、不管你写不写初始化列表，成员变量一定会走一遍

5、如果初始化列表没有显示给值，缺省值是给初识化列表使用

6、并且编译器运行时，按照声明的顺序进行初始化列表

7、三类必须放在初始化列表进行初始化：
    1、引用成员变量；
    2、const成员变量；
    3、自定义类型成员（且没有默认构造函数的）



## explicit
A aa2=2
c++支持单参数构造函数的隐式类型转换，用2调用A构造函数生成一个临时对象，在用这个对象去拷贝构造，而编译器会在优化，用2直接构造

多参数：B bb1(1,1);or B bb2 = {2,2};//c++11支持

若不想让隐式类型转换，则在构造函数前添加


## 匿名对象
形如：A(7);
特点：生命周期只在这一行，而有名对象的生命周期在局部域
用处：简化代码，在传参时使用匿名对象，

## static成员
统计累计创建一个类的个数：在拷贝和构造++
统计一个类正在使用的个数：析构时--
但是需要防止随意修改
引用传参和引用返回可以减少构造次数 
static 属于所有对象，成为静态对象，且不能给初始值static int m;
静态对象存在静态区，在类中声明，在类外定义

属于整个类 

静态成员函数：static int xxx()
特点：
没有this指针
静态成员函数不能访问非静态，因为没有this指针
举个例子：1+2+3+4+...+n
`
class sum
{
public:
    sum()
    {
        _ret+=_i;
        _i++;
    }
private：
    static int _i;//静态成员函数，属于所有的变量
    static int _ret;
};
int sum::_i=1;
int sum::_ret=0;

class solution{
public:
    int sum_sulution(int n){
        sum a[n];//变长数组

    }
};
`
## 友元-?谨慎的使用->尽可能少用->发临时性的最好
### 友元函数
在内部用friend声明，没有this指针，不能用const修饰
friend ostream& operator<<(ostream& _cout,const date&d);

### 友元类
`
类中所有都可以进出，date可以访问time的私有，但time无法访问date的私有
是单向的不具有交换性
无传递性
class time
{
    friend class date;
}
class date{

}


## 内部类
类的嵌套，在一个类中去定义另外一个类
B类受A类域和访问限定符的限制，其实他们是两个独立的类，只是访问的限制，如果定义成私有，只有A类可以使用，外部无法使用，
反过来说，内部类是外部类的友元
class A{
public:
    class B
    {

        private:
        int _b;
    }



private:
    int _a;

};

`

## 拷贝对象时的一些编译器优化
传引用会减少拷贝构造，但是要注意const
一是权限问题，而是可以延长匿名对象生命周期
连续的构造会被编译器优化，c++并没有规定此标准不过